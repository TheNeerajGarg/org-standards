#!/bin/bash
# Pre-push Hook: Quality Gates Enforcement
# Configuration-driven - reads from org-standards/config/quality-gates.yaml
#
# Source: org-standards/git-hooks/pre-push
# Version: 2.0.0 (2025-10-23) - Configuration-driven
#
# Philosophy: Enforce quality before sharing code
# This is the primary quality gate - blocks push if standards not met

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo ""
echo -e "${BLUE}ðŸš€ Pre-push quality gates (configuration-driven)...${NC}"
echo ""

# ============================================================================
# Emergency Bypass with JSON Logging
# ============================================================================

if [ "$EMERGENCY_PUSH" = "1" ]; then
    echo -e "${RED}âš ï¸  EMERGENCY PUSH DETECTED${NC}"
    echo -e "${RED}âš ï¸  Bypassing all quality gates${NC}"
    echo ""

    # Create bypass log directory
    mkdir -p .emergency-bypasses

    # Generate timestamp-based filename
    TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
    BYPASS_FILE=".emergency-bypasses/${TIMESTAMP}.json"

    # Get reason from environment or use default
    REASON="${EMERGENCY_REASON:-No reason provided}"

    # Get current user and branch
    USER=$(git config user.name || echo "unknown")
    EMAIL=$(git config user.email || echo "unknown")
    BRANCH=$(git rev-parse --abbrev-ref HEAD)
    COMMIT=$(git rev-parse HEAD)

    # Write JSON log
    cat > "$BYPASS_FILE" <<EOF
{
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "user": "$USER",
  "email": "$EMAIL",
  "branch": "$BRANCH",
  "commit": "$COMMIT",
  "reason": "$REASON",
  "event": "emergency_push",
  "bypassed_gates": "all"
}
EOF

    echo -e "${YELLOW}ðŸ“ Bypass logged to: ${BYPASS_FILE}${NC}"
    echo ""
    echo -e "${YELLOW}âš ï¸  You MUST:${NC}"
    echo "   1. Create issue to fix quality violations"
    echo "   2. Document reason in commit/PR"
    echo "   3. Fix within 24 hours"
    echo ""
    echo "Pushing without validation..."
    exit 0
fi

# ============================================================================
# Configuration-Driven Quality Gate Execution
# ============================================================================

# Get repository root
REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT"

# Check if quality_gates module exists
if [ ! -f "org-standards/python/quality_gates.py" ]; then
    echo -e "${RED}âŒ ERROR: Quality gates module not found${NC}"
    echo ""
    echo "Expected: org-standards/python/quality_gates.py"
    echo ""
    echo "Fix: Update org-standards submodule"
    echo "  git submodule update --remote org-standards"
    echo ""
    exit 1
fi

# Check if config exists
if [ ! -f "org-standards/config/quality-gates.yaml" ]; then
    echo -e "${RED}âŒ ERROR: Quality gates config not found${NC}"
    echo ""
    echo "Expected: org-standards/config/quality-gates.yaml"
    echo ""
    echo "Fix: Update org-standards submodule"
    echo "  git submodule update --remote org-standards"
    echo ""
    exit 1
fi

# Execute quality gates using Python module
echo -e "${BLUE}ðŸ“‹ Loading configuration from org-standards/config/quality-gates.yaml${NC}"
echo ""

python3 << 'PYTHON_SCRIPT'
import sys
import os

# Add org-standards/python to path
sys.path.insert(0, "org-standards/python")

try:
    from quality_gates import load_config, execute_gates

    # Load configuration
    config = load_config()

    print(f"Configuration loaded: version {config.version}")
    print(f"Gates to execute: {len([g for g in config.gates.values() if g.enabled])}/{len(config.gates)}")
    print("")

    # Execute gates
    results = execute_gates(config, phase="pre-push")

    # Print summary
    print("")
    print("=" * 70)
    print(f"Results: {results.total_count} gates executed in {results.duration_seconds:.1f}s")
    print(f"  âœ… Passed: {results.total_count - results.failed_count}")
    print(f"  âŒ Failed: {results.failed_count}")
    print("=" * 70)

    # Exit with appropriate code
    if results.passed:
        print("")
        print("âœ… All quality gates passed - push allowed")
        print("")
        sys.exit(0)
    else:
        print("")
        print("âŒ Quality gates failed - push blocked")
        print("")
        print("Failed gates:")
        for failure in results.failures:
            print(f"  - {failure.gate_name}: {failure.message[:100]}")
            if failure.fail_message:
                print(f"    Fix: {failure.fail_message}")
        print("")
        print("Emergency bypass (use with caution):")
        print("  EMERGENCY_PUSH=1 EMERGENCY_REASON='reason' git push")
        print("")
        sys.exit(1)

except ImportError as e:
    print(f"âŒ ERROR: Failed to import quality_gates module", file=sys.stderr)
    print(f"   {e}", file=sys.stderr)
    print("", file=sys.stderr)
    print("Install dependencies: pip install pyyaml", file=sys.stderr)
    sys.exit(1)
except FileNotFoundError as e:
    print(f"âŒ ERROR: Configuration file not found", file=sys.stderr)
    print(f"   {e}", file=sys.stderr)
    sys.exit(1)
except Exception as e:
    print(f"âŒ ERROR: Quality gate execution failed", file=sys.stderr)
    print(f"   {e}", file=sys.stderr)
    sys.exit(1)
PYTHON_SCRIPT

# Capture Python script exit code
GATE_RESULT=$?

# Exit with same code
exit $GATE_RESULT
